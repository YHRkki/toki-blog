#### Mobx Redux

> `Mobx`的实现思想和`Vue`几乎一样，所以其优点跟`Vue`也差不多：通过监听数据（对象、数组）的属性变化，可以通过直接在数据上更改就能触发` UI `的渲染，从而做到`MVVM`、响应式、上手成本低、开发效率高，在数据管理上需要再详细阐述下其区别。
>
> `Redux`是建议全局唯一`Store`的，多个`Reducers`也会在传递给`react-redux`之前被合并成一个`root reducer`，任何数据的更改（通过Reducer）都会通过这一个store来触发整个`UI`树的重新渲染，如果不做任何的性能优化（`pureRender`等），就算`VD(Virtual Dom)`有了再高的效率提升，当页面数据量、`DOM`数量大了，性能消耗也是非常大的。另外一点，`Redux`实现的对数据的管理是pull方式的，就是说其只能等待应用派发某个行为（Action），然后重新触发`UI`的渲染，而做不到对行为的可预期；`Mobx`则不一样，他是基于监听数据的属性变化来实现的，而且是多store的，对于任何的数据变更都是第一时间知道的，所以其实现方式是基于push的监听订阅模式而实现，这样，他就可以做到对数据的可预测以及细粒度的控制，甚至可以通过修改React组件生命周期的方式来减少性能的消耗，而无需使用者对这些细节关心。当然这一切肯定是有了`mobx`对组件做`observe`操作才能实现的，所以也就有了`observer`用的越多，应用性能越高的说法。

#### 我们要解决的是什么问题？

> 如今的现状是要用组件（components）来构建一个前端应用。组件有自己的内部状态。举个栗子，在 React 中上述的本地状态是用`this.state`和`setState()`来处理。但本地状态的状态管理在膨胀的应用中很快会变得混乱，因为：
>
> - 一个组件需要和另一个组件共享状态
> - 一个组件需要改变另一个组件的状态
>
> 到一定程度时，推算应用的状态将会变得越来越困难。它就会变成一个有很多状态对象并且在组件层级上互相修改状态的混乱应用。在大部分情况下，状态对象和状态的修改并没有必要绑定在一些组件上。[当你把状态提升时，它们可以通过组件树得到](https://facebook.github.io/react/docs/lifting-state-up.html)。
>
> 所以，解决方案是引入状态管理库，比如：`Mobx 或 Redux`。它提供工具在某个地方保存状态、修改状态和更新状态。你可以从一个地方获得状态，一个地方修改它，一个地方得到它的更新。它遵循单一数据源的原则。这让我们更容易推断状态的值和状态的修改，因为它们与我们的组件是解耦的。

####  Mobx 和 Redux 的不同？

> 这两个库都是用来管理 JavaScript 应用的状态。它们并不一定要跟 React 绑定在一起，它们也可以在 AngularJs 和 VueJs 这些其他库里使用。但它们与[ React 的理念](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/)结合得非常好。
>
> 你的 Redux state 是不可变的，你应该总是返回一个新的 state 而不是修改原 state。你不应该执行 state 的修改或依据对象引用的更改。
>
> Mobx 则是受到面向对象编程和响应式编程的影响。它将 state 包装成可观察的对象，因此你的 state 就有了 Observable 的所有能力。state 数据可以只有普通的 setter 和 getter，但 observable 让我们能在数据改变的时候得到更新的值。