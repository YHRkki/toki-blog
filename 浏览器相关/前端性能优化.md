## 减少 HTTP 请求

    每发起一个 HTTP 请求，都得经历三次握手建立 TCP 连接，如果连接只用来交换少量数据，这个过程就会严重降低 HTTP 性能。所以我们可以将多个小文件合成一个大文件，从而减少 HTTP 请求次数。

    其实由于持久连接（重用 TCP 连接，以消除连接及关闭时延；HTTP/1.1 默认开启持久连接）的存在，每个新请求不一定都需要建立一个新的 TCP 连接。但是，浏览器处理完一个 HTTP 请求才能发起下一个，所以在 TCP 连接数没达到浏览器规定的上限时，还是会建立新的 TCP 连接。从这点来看，减少 HTTP 请求仍然是有必要的。
## 使用 HTTP2
    HTTP2 相比 HTTP1.1 有如下几个优点：
    解析速度快
    服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。

    多路复用
    HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。
    在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。
    多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。

    首部压缩
    HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。
    仅发送它们之间不同的部分，可以节省不少的流量，加快请求的时间。

    服务器推送
    服务器可以对一个客户端请求发送多个响应

## 静态资源使用 CDN
    内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

## 善用缓存
    为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 头来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。

    不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？

    可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。

    具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用数据摘要要算法对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。

## 压缩文件
    压缩文件可以减少文件下载时间，让用户体验性更好。

    gzip 是目前最流行和最有效的压缩方法。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。

    举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。

## 通过 max-age 和 no-cache 实现文件精确缓存
    通用消息头部 Cache-Control 其中有两个选项：

    max-age: 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。在这个时间前，浏览器读取文件不会发出新请求，而是直接使用缓存。
    no-cache: 指定 no-cache 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。

    我们可以将那些长期不变的静态资源设置一个非常长的缓存时间，例如设置成缓存一年。

    然后将 index.html 文件设置成 no-cache。这样每次访问网站时，浏览器都会询问 index.html 是否有更新，如果没有，就使用旧的 index.html 文件。如果有更新，就读取新的 index.html 文件。当加载新的 index.html 时，也会去加载里面新的 URL 资源。

    例如 index.html 原来引用了 a.js 和 b.js，现在更新了变成 a.js 和 c.js。那就只会加载 c.js 文件。

    具体请看 webpack + express 实现文件精确缓存。

## 将 CSS 放在文件头部，JavaScript 文件放在底部
    CSS 执行会阻塞渲染，阻止 JS 执行
    JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建

## 使用字体图标 iconfont 代替图片图标
    使用时就跟字体一样，可以设置属性,非常方便，优点是生成的文件特别小

## 调整图片大小

## 降低图片质量
    通过 webpack 插件 image-webpack-loader 转换成base64

## 使用 webp 格式的图片
    WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式
## 减少重绘重排
    例如 DocumentFragment（文档片段）

    它被作为一个轻量版的 Document 使用，就像标准的 document 一样，存储由节点（nodes）组成的文档结构。与 document 相比，最大的区别是它不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会对性能产生影响。

## 使用事件委托
```js
// 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。
// 所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。
<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>凤梨</li>
</ul>

// good
document.querySelector('ul').onclick = (event) => {
  const target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
  }
}

// bad
document.querySelectorAll('li').forEach((e) => {
  e.onclick = function() {
    console.log(this.innerHTML)
  }
})
```

## 使用 requestAnimationFrame 来实现动画
    `requestAnimationFrame` 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率

    在隐藏或不可见的元素中，`requestAnimationFrame` 将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量

    `requestAnimationFrame` 是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销

## 使用 transform 和 opacity 属性更改来实现动画
    在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。

[参考链接1](https://github.com/woai3c/Front-end-articles/blob/master/http-https-http2.md)

[参考链接2](https://juejin.cn/post/6892994632968306702#heading-47)